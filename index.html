<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
    <title>GIT</title>
</head>
<body>
    <div class="name">
        <h1>GIT 강의 정리</h1>
        <ul>
            <li>
                <h2>GIT설치</h2>
                <p>
                    구글에 GIT 검색 후 들어가서 다운받아 대충 설치하면 됨<br/>
                    설치할때 기본 에디터 vs code로 수정<br/>
                    기본 브랜치 이름 main으로 놓기 끝.
                </p>
            </li>
            <li>
                <h2>유저 이름 세팅</h2>
                <p>
                    작업 폴더에 shift + 우클릭 / powerShell 열기<br/>
                    git config --global user.email "홍길동@naver.com"<br/>
                    git config --global user.name "홍길동" 입력.
                </p>
            </li>
            <li>
                <h2>버전 등록 방법</h2>
                <ul>
                    <li>파일 생성(작업파일) / 에디터로 열기</li>
                    <li>터미널 열어 git init작성 -> 이후 작성되는 코드 및 파일생성 추적 시작</li>
                    <li>코딩</li>
                    <li>git add 파일명 -> staging area(버전 관리 할 파일 골라내기)</li>
                    <li>git commot -m '메모' 입력 / 끝. -> repository(저장소에 저장)</li>
                    <li>간단한 기능 하나 추가 및 수정시 commit하기 </li>
                </ul>
            </li>
            <li>
                <h2>다양한 git 명령어</h2>
                <ul>
                    <li>git add app.txt index.html ->여러개 파일을 staging</li>
                    <li>git add . -> 작업폴더 안의 모든 파일을 staging</li>
                    <li>git status -> staging한 파일을 확인 가능</li>
                    <li>git restore --staged 파일명 -> 스테이징된 파일들 취소</li>
                    <li>git log --all --oneline -> 지금까지 버전관리 한 내역 볼 수 있음</li>
                    <li></li>
                </ul>
            </li>
            <li>
                <h2>git branch</h2>
                <p>git branch를 이용하면 기능 개발을 위한 테스트 파일을 쉽게 생성, 삭제할 수 있음 / 테스트파일을 staging, commit도 가능</p>
                <ul>
                    <li>터미널에 입력</li>
                    <li>명령어 - git branch 이름</li>
                    <li>명령어 - git switch 이름(생성된 브렌치로 이동)</li>
                    <li>기능개발</li>
                    <li>git add . / git commit -m ''등을 이용하여 staging, commit 버전관리</li>
                    <li>기능 다 개발했으면 테스트하고 원본에 복붙</li>
                    <li>git switch master로 원래 브렌치로 돌아옴. 생성된 브렌치의 파일은 사라짐</li>
                    <li>git switch 이름으로 해당 브렌치로 돌아가면 사라졌던 파일이 보여짐</li>
                    <li></li>
                </ul>
            </li>
            <li>
                <h2>git merge</h2>
                <p>git merge를 이용하면 branch에 만들었던 파일들을 전부 master로 합쳐올 수 있음</p>
                <ul>
                    <li>명령어 - git merge 브랜치 이름</li>
                    <li>주의할 점은 제각기 다른 파일들이면 충돌없이 무사히 합쳐지지만 같은 파일명이 있을경우 충돌이 일어남</li>
                    <li>에러가 나는 지점으로 가서 필요한 코드들만 남기고 전부 지우기 -> staging / commit 하기</li>
                    <li>git branch -d 브랜치 이름 -> merge 완료된 해당 브랜치 삭제</li>
                    <li>merge가 되지 않은 브랜치의 경우 git branch -D 브랜치 이름을 입력하면 삭제 가능</li>
                </ul>
            </li>
            <li>
                <h2>3-way-merge</h2>
                <p>브랜치에 각각 신규 commit이 1회 이상 있는 경우 merge 명령을 내리면 두 브랜치의 코드를 합쳐서 새로운 commit을 자동으로 생성해주는데 이게 3-way-merge임(merge의 기본 동작 방식)</p>
            </li>
            <li>
                <h2>fast-forward merge</h2>
                <p>새로운 브랜치에만 commit 이 있고  기준이 되는 브랜치에는 신규 commit 이 없는 경우 merge 하게 되면 "fast-forward merge 되었습니다" 라고 알려줌</p>
                <p>딱히 합칠게 없어서 그냥 신규브랜치 보고 "지금부터 니 이름은 main 브랜치여" 하는 것(그냥 결과는 같다)</p>
                <p>그래서 "기준이 되는 브랜치에 신규 commit이 없으면" 자동으로 fast-forward merge가 발동</p>    
            </li>
            <li>
                <h2>rebase</h2>
                <p>rebase는 브랜치의 시작점을 다른 commit으로 옮겨주는 행위</p>
                <ul>
                    <li>rebase를 이용해서 신규브랜치의 시작점을 main 브랜치 최근 commit으로 옮김</li>
                    <li>fast-forward merge하는 것입니다.</li>
                    <li>명령어 순서</li>
                    <li>
                        git switch 새로운브랜치<br/>
                        git rebase main<br/><br/>            
                        git switch main<br/>
                        git merge 새로운브랜치<br/>
                    </li>
                </ul>
            </li>
            <li>
                <h2>squash and merge</h2>
                <p>merge를 대충 3-way-merge하면 관리하기 힘듬</p>
                <ol>
                    <li>3-way merge 된 것들은 매우 복잡해보임</li>
                    <li>main 브랜치 git log 출력해보면 3-way merge된 브랜치들의 commit 내역도 다 같이 출력되어서 더러워짐</li>
                </ol>
                <br/>
                <br/>
                <p>squash and merge하면 새 브랜치에 있던 코드변경사항들이 main 브랜치로 텔레포트합니다.</p>
                <p>이렇게 하면 main 브랜치의 git log 출력해볼 때 merge 완료된 브랜치의 commit 같은 것들은 출력되지 않음</p>
                <p>순서 : <br/> 
                    git switch main<br/> 
                    git merge --squash 브랜치명<br/> 
                    git commit -m '메세지'<br/> 
                </p>
            </li>
            <li>
                <h2>git restore</h2>
                <p>파일 하나를 되돌리는 경우 사용</p>
                <ul>
                    <li>git restore 파일명 ->최근 commit 된 상태로 현재 파일의 수정내역을 되돌림</li>
                    <li>git restore --source 커밋아이디 파일명 -> 입력한 파일이 특정 커밋아이디 시점으로 복구</li>
                    <li>git restore --staged 파일명 -> 특정 파일의 staging 취소</li>
                </ul>
            </li>
            <li>
                <h2>git revert</h2>
                <p>특정 파일의 commit을 취소(되돌림) ->  commit 하나를 취소한 commit을 하나 생성</p>
                <p>git revert 커밋아이디</p>
                <ul>
                    <li>revert 할 때 동시에 여러개의 commit id 입력가능 </li>
                    <li>최근 했던 commit 1개만 revert하고 싶으면 git revert HEAD</li>
                    <li>merge 명령으로 인해 새로 만들어진 commit도 revert 가능</li>
                </ul>
            </li>
            <li>
                <h2>git reset</h2>
                <ul>
                    <li>git reset --hard 커밋아이디 -> 해당 커밋이 생성될 때로 시간을 되돌려줍니다. </li>
                </ul>
            </li>
        </ul>
    </div>
</body>
</html>